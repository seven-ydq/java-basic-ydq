## sleep与wait的区别

1、sleep是Thread类的方法，wait是Object类的方法

2、使用上，sleep方法可以在任何地方使用，wait方法必须在同步代码块中使用，否则会报illegalMonitorStateException，而且sleep方法必须声明捕获异常

3、在锁机制上，sleep方法调用之后，并没有释放锁，线程仍然可以同步控制，且sleep不会让出系统资源；wait方法调用之后会释放锁并让出系统资源，线程进入线程等待池中等待；

4、虽然都可以设置时间，但sleep的时间是等待时间，系统严格按照设定的millis时间恢复线程的运行状态；但wait的时间是一个timeout时间，wait到时候还需进入就绪队列再次等待锁资源，因此这个具体恢复运行状态的时间不固定。



## 以下情况，当前线程会放弃CPU执行权：

1、线程调用了sleep、wait、yield等方法，或者I/O访问，等待用户输入等原因导致线程进入阻塞状态；

2、抢先式系统下，更高级别的线程抢占了CPU资源，当前正在run的线程不得不进入等待执行队列

3、时间片方式下当前时间用完，同优先级的线程参与了调度，当前线程不得不进入等待执行队列

## 互斥与同步

线程互斥：两个线程同时执行，线程之间的操作互相不影响

线程同步：两个线程同时执行，执行到同步代码块时，一个执行其他等待



## 异步与同步



## 什么情况下会出现线程安全问题

1、多个线程共享同一资源

## 解决方案：

基本上所有的并发模式在解决线程安全问题上，都采用“序列化访问临界资源”的方案，即在同一时刻，只能有一个线程访问临界资源，也称同步互斥访问。通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问。在Java中，提供了两种方式来实现同步互斥访问：synchronized和Lock。